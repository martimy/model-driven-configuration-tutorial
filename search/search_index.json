{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Model-Driven Network Configuration Tutorial This tutorial teaches you how to configure network devices using YANG data models. The tutorial is built on Containerlab, an open-source network emulation platform that spins up virtual instances of Nokia SR-Linux and Arista cEOS routers on your laptop. Prerequisites Familiarity with networking fundamentals: IP addressing, routing protocols, etc. Comfort with the Linux command line and a text editor Objectives --to be completed-- Tasks Each task introduces a concept, and then provides a set of instructions to explore or implement the concept. Complete the tasks in order as eah taks build upon the previous one.","title":"Home"},{"location":"#model-driven-network-configuration-tutorial","text":"This tutorial teaches you how to configure network devices using YANG data models. The tutorial is built on Containerlab, an open-source network emulation platform that spins up virtual instances of Nokia SR-Linux and Arista cEOS routers on your laptop.","title":"Model-Driven Network Configuration Tutorial"},{"location":"#prerequisites","text":"Familiarity with networking fundamentals: IP addressing, routing protocols, etc. Comfort with the Linux command line and a text editor","title":"Prerequisites"},{"location":"#objectives","text":"--to be completed--","title":"Objectives"},{"location":"#tasks","text":"Each task introduces a concept, and then provides a set of instructions to explore or implement the concept. Complete the tasks in order as eah taks build upon the previous one.","title":"Tasks"},{"location":"concepts/gnmi/","text":"gNMI gNMI (gRPC Network Management Interface) is a gRPC-based protocol developed by the OpenConfig project for configuration management and streaming telemetry on network devices (routers, switches, etc.). It provides a single, unified, high-performance service for both modifying/retrieving configuration and generating real-time telemetry streams. Current specification: version 0.10.0 (published 2023), defined via Protocol Buffers (proto3) in the openconfig/gnmi GitHub repository. It was created to address the need for efficient, model-driven management - combining configuration (like NETCONF) and telemetry (previously handled separately, e.g., via SNMP traps or proprietary mechanisms) into one modern, binary-efficient protocol built on gRPC. Key Characteristics Uses gRPC over TLS (>=1.2) for secure, bidirectional communication; mutual authentication via X.509 certificates is required. Encoding \u2192 Protocol Buffers (preferred for efficiency) with TypedValue (scalars: string, int64, uint64, bool, double, bytes, arrays); also supports JSON, JSON_IETF (RFC 7951), Bytes, ASCII. JSON is mandatory minimum support. Paths \u2192 XPath-like, structured as ordered lists of PathElem (name + optional key-value pairs); support prefix for common base paths, wildcards (*), origins (e.g., \"openconfig\", \"cli\" for vendor-specific). Schema-agnostic at protocol level but designed for YANG/OpenConfig models; uses origin field to disambiguate schemas. Supports transactional configuration changes (atomic all-or-nothing). Streaming telemetry via long-lived subscriptions with multiple modes. Single gRPC service with four RPCs. Main Operations (RPCs) Capabilities : Discovery handshake: reports supported models (name/org/version), encodings, gNMI version, extensions. Get : Retrieve snapshot of data for specified paths; filter by datatype (CONFIG, STATE, OPERATIONAL); returns timestamped Notification messages with updates/deletes. Set : Atomic modification: supports delete (recursive), replace (full subtree overwrite), update (merge leaf changes), union_replace; operations processed in order (delete \u2192 replace \u2192 update); full rollback on failure. Subscribe - Streaming telemetry: ONCE \u2192 one-off sync, closes after initial data. POLL \u2192 long-lived, client-triggered updates via Poll messages. STREAM \u2192 continuous: ON_CHANGE \u2192 push on value change + optional heartbeat. SAMPLE \u2192 periodic (nanosecond interval) + suppress_redundant option. TARGET_DEFINED \u2192 device decides per-leaf mode. Supports qos marking, updates_only (skip initial sync), aggregation. Configuration vs Telemetry Handling Configuration \u2192 read/write (\"config true\" in YANG); modified via Set. State/Operational \u2192 read-only telemetry data; retrieved via Get or Subscribe. No separate datastores like NETCONF (candidate/running); changes are direct but atomic. Advantages Unified interface for config + telemetry \u2192 simplifies client and device implementations. High performance \u2192 gRPC streaming + binary Protobuf encoding \u2192 low latency/overhead for large-scale telemetry. Real-time push telemetry (vs. polling) with fine-grained modes (change detection, sampling). Model-driven \u2192 strong OpenConfig YANG alignment for vendor neutrality; capabilities ensure compatibility. Secure by default \u2192 TLS mandatory, supports per-RPC authorization. Better suited for SDN, automation pipelines, and large-scale monitoring than legacy protocols. gNMI has become a cornerstone of modern network automation and telemetry, widely adopted by vendors (Cisco, Juniper, Arista, Nokia, etc.) alongside OpenConfig models, complementing NETCONF (configuration-focused) with superior streaming capabilities.","title":"gNMI"},{"location":"concepts/gnmi/#gnmi","text":"gNMI (gRPC Network Management Interface) is a gRPC-based protocol developed by the OpenConfig project for configuration management and streaming telemetry on network devices (routers, switches, etc.). It provides a single, unified, high-performance service for both modifying/retrieving configuration and generating real-time telemetry streams. Current specification: version 0.10.0 (published 2023), defined via Protocol Buffers (proto3) in the openconfig/gnmi GitHub repository. It was created to address the need for efficient, model-driven management - combining configuration (like NETCONF) and telemetry (previously handled separately, e.g., via SNMP traps or proprietary mechanisms) into one modern, binary-efficient protocol built on gRPC.","title":"gNMI"},{"location":"concepts/gnmi/#key-characteristics","text":"Uses gRPC over TLS (>=1.2) for secure, bidirectional communication; mutual authentication via X.509 certificates is required. Encoding \u2192 Protocol Buffers (preferred for efficiency) with TypedValue (scalars: string, int64, uint64, bool, double, bytes, arrays); also supports JSON, JSON_IETF (RFC 7951), Bytes, ASCII. JSON is mandatory minimum support. Paths \u2192 XPath-like, structured as ordered lists of PathElem (name + optional key-value pairs); support prefix for common base paths, wildcards (*), origins (e.g., \"openconfig\", \"cli\" for vendor-specific). Schema-agnostic at protocol level but designed for YANG/OpenConfig models; uses origin field to disambiguate schemas. Supports transactional configuration changes (atomic all-or-nothing). Streaming telemetry via long-lived subscriptions with multiple modes. Single gRPC service with four RPCs.","title":"Key Characteristics"},{"location":"concepts/gnmi/#main-operations-rpcs","text":"Capabilities : Discovery handshake: reports supported models (name/org/version), encodings, gNMI version, extensions. Get : Retrieve snapshot of data for specified paths; filter by datatype (CONFIG, STATE, OPERATIONAL); returns timestamped Notification messages with updates/deletes. Set : Atomic modification: supports delete (recursive), replace (full subtree overwrite), update (merge leaf changes), union_replace; operations processed in order (delete \u2192 replace \u2192 update); full rollback on failure. Subscribe - Streaming telemetry: ONCE \u2192 one-off sync, closes after initial data. POLL \u2192 long-lived, client-triggered updates via Poll messages. STREAM \u2192 continuous: ON_CHANGE \u2192 push on value change + optional heartbeat. SAMPLE \u2192 periodic (nanosecond interval) + suppress_redundant option. TARGET_DEFINED \u2192 device decides per-leaf mode. Supports qos marking, updates_only (skip initial sync), aggregation.","title":"Main Operations (RPCs)"},{"location":"concepts/gnmi/#configuration-vs-telemetry-handling","text":"Configuration \u2192 read/write (\"config true\" in YANG); modified via Set. State/Operational \u2192 read-only telemetry data; retrieved via Get or Subscribe. No separate datastores like NETCONF (candidate/running); changes are direct but atomic.","title":"Configuration vs Telemetry Handling"},{"location":"concepts/gnmi/#advantages","text":"Unified interface for config + telemetry \u2192 simplifies client and device implementations. High performance \u2192 gRPC streaming + binary Protobuf encoding \u2192 low latency/overhead for large-scale telemetry. Real-time push telemetry (vs. polling) with fine-grained modes (change detection, sampling). Model-driven \u2192 strong OpenConfig YANG alignment for vendor neutrality; capabilities ensure compatibility. Secure by default \u2192 TLS mandatory, supports per-RPC authorization. Better suited for SDN, automation pipelines, and large-scale monitoring than legacy protocols. gNMI has become a cornerstone of modern network automation and telemetry, widely adopted by vendors (Cisco, Juniper, Arista, Nokia, etc.) alongside OpenConfig models, complementing NETCONF (configuration-focused) with superior streaming capabilities.","title":"Advantages"},{"location":"concepts/motivation/","text":"Motivation Modern networks are no longer small, static environments managed primarily through manual configuration. Today\u2019s infrastructures are large-scale, multi-vendor, automated, and continuously changing, which requires management interfaces that are reliable, structured, and programmatically accessible. Traditional router configuration approaches\u2014especially those centered on CLI interaction\u2014are increasingly inadequate for these environments. While the CLI remains useful for human operators, it does not scale well for automation. Techniques such as screen scraping or scripting interactive sessions (for example, using expect-like tools) are fragile and difficult to maintain, particularly in complex production networks. As networks grow in size and diversity, these approaches become error-prone and operationally inefficient. To address these challenges, modern network systems are evolving toward an API-first architecture. In this model, configuration and operational state are accessed through structured programmatic interfaces, while the CLI is repositioned as just another client layered on top of these APIs rather than being the primary control interface. The most significant architectural shift enabling this transition is the adoption of model-driven management, centered around the YANG data modeling language. Instead of writing configuration logic tied to a specific interface (such as CLI command handlers), developers define a structured data model describing configuration and state. Management interfaces\u2014whether CLI, NETCONF, RESTCONF, or others\u2014interact with the same underlying model. This approach provides several key advantages: Interface independence: Configuration logic is written once and reused across multiple management protocols. Consistency: The same validation and processing logic is applied regardless of whether changes originate from automation tools or manual CLI input. Extensibility: New management interfaces can be introduced without redesigning the internal configuration logic. Automation readiness: Structured data models align naturally with modern automation workflows. As described in RFC 7950, YANG was originally designed to model data for the NETCONF protocol, defining hierarchical structures for configuration data, operational state, RPCs, and notifications. Although closely associated with NETCONF, YANG is protocol-independent and is now widely used with multiple management frameworks, including RESTCONF and gNMI. In a model-driven architecture, configuration changes are no longer interpreted as sequences of CLI commands. Instead, they are treated as structured data transactions validated against the YANG model and processed through common callback logic. For example, whether a configuration change originates from a NETCONF session or a CLI terminal, the same internal processing pipeline is used. This ensures feature parity and consistent behavior across all management interfaces.","title":"Motivation"},{"location":"concepts/motivation/#motivation","text":"Modern networks are no longer small, static environments managed primarily through manual configuration. Today\u2019s infrastructures are large-scale, multi-vendor, automated, and continuously changing, which requires management interfaces that are reliable, structured, and programmatically accessible. Traditional router configuration approaches\u2014especially those centered on CLI interaction\u2014are increasingly inadequate for these environments. While the CLI remains useful for human operators, it does not scale well for automation. Techniques such as screen scraping or scripting interactive sessions (for example, using expect-like tools) are fragile and difficult to maintain, particularly in complex production networks. As networks grow in size and diversity, these approaches become error-prone and operationally inefficient. To address these challenges, modern network systems are evolving toward an API-first architecture. In this model, configuration and operational state are accessed through structured programmatic interfaces, while the CLI is repositioned as just another client layered on top of these APIs rather than being the primary control interface. The most significant architectural shift enabling this transition is the adoption of model-driven management, centered around the YANG data modeling language. Instead of writing configuration logic tied to a specific interface (such as CLI command handlers), developers define a structured data model describing configuration and state. Management interfaces\u2014whether CLI, NETCONF, RESTCONF, or others\u2014interact with the same underlying model. This approach provides several key advantages: Interface independence: Configuration logic is written once and reused across multiple management protocols. Consistency: The same validation and processing logic is applied regardless of whether changes originate from automation tools or manual CLI input. Extensibility: New management interfaces can be introduced without redesigning the internal configuration logic. Automation readiness: Structured data models align naturally with modern automation workflows. As described in RFC 7950, YANG was originally designed to model data for the NETCONF protocol, defining hierarchical structures for configuration data, operational state, RPCs, and notifications. Although closely associated with NETCONF, YANG is protocol-independent and is now widely used with multiple management frameworks, including RESTCONF and gNMI. In a model-driven architecture, configuration changes are no longer interpreted as sequences of CLI commands. Instead, they are treated as structured data transactions validated against the YANG model and processed through common callback logic. For example, whether a configuration change originates from a NETCONF session or a CLI terminal, the same internal processing pipeline is used. This ensures feature parity and consistent behavior across all management interfaces.","title":"Motivation"},{"location":"concepts/netconf/","text":"NETCONF NETCONF (Network Configuration Protocol) is an IETF-standardized network management protocol (RFC 6241, RFC 4741) designed to securely install, manipulate, modify, and delete configuration data on network devices such as routers, switches, and firewalls. It was created to overcome limitations of older approaches like SNMP (which lacks robust configuration control) and manual/automated CLI scripting (which can be insecure, inconsistent, and hard to automate reliably). Key Characteristics Uses XML for encoding both protocol messages and configuration data \u2192 structured, hierarchical, and machine-readable. Follows a client-server model with Remote Procedure Call (RPC) communication. Runs over secure, connection-oriented transports, most commonly SSH (port 830), but also supports TLS and others. Organized in four conceptual layers: Content layer (configuration data, often modeled with YANG). Operations layer (core RPC operations). Messages layer (framing RPCs and notifications). Secure transport layer. Main Operations <get> : Retrieve running state and configuration data. <get-config> : Retrieve configuration from a specific datastore. <edit-config> : Load or modify configuration data. <copy-config> : Replace entire datastore contents. <delete-config> : Remove a non-running datastore. <lock> / <unlock> : Prevent concurrent modifications. <close-session> / <kill-session> : End sessions gracefully or forcefully. Supports notifications (e.g., RFC 5277) for asynchronous event reporting. Configuration Datastores Devices maintain separate datastores (e.g., running, candidate, startup), allowing changes to be staged, validated, and committed atomically : a major improvement for safe automation. Advantages Secure by design (strong transport encryption + authentication). Transaction-like behavior and rollback support. Programmable and automation-friendly, especially when combined with YANG data models. Better suited for large-scale, programmatic network management than SNMP or CLI scraping. NETCONF has become a foundational protocol for modern network automation, SDN, and intent-based networking, widely supported by vendors like Cisco, Juniper, Nokia, Huawei, and others.","title":"NETCONF"},{"location":"concepts/netconf/#netconf","text":"NETCONF (Network Configuration Protocol) is an IETF-standardized network management protocol (RFC 6241, RFC 4741) designed to securely install, manipulate, modify, and delete configuration data on network devices such as routers, switches, and firewalls. It was created to overcome limitations of older approaches like SNMP (which lacks robust configuration control) and manual/automated CLI scripting (which can be insecure, inconsistent, and hard to automate reliably).","title":"NETCONF"},{"location":"concepts/netconf/#key-characteristics","text":"Uses XML for encoding both protocol messages and configuration data \u2192 structured, hierarchical, and machine-readable. Follows a client-server model with Remote Procedure Call (RPC) communication. Runs over secure, connection-oriented transports, most commonly SSH (port 830), but also supports TLS and others. Organized in four conceptual layers: Content layer (configuration data, often modeled with YANG). Operations layer (core RPC operations). Messages layer (framing RPCs and notifications). Secure transport layer.","title":"Key Characteristics"},{"location":"concepts/netconf/#main-operations","text":"<get> : Retrieve running state and configuration data. <get-config> : Retrieve configuration from a specific datastore. <edit-config> : Load or modify configuration data. <copy-config> : Replace entire datastore contents. <delete-config> : Remove a non-running datastore. <lock> / <unlock> : Prevent concurrent modifications. <close-session> / <kill-session> : End sessions gracefully or forcefully. Supports notifications (e.g., RFC 5277) for asynchronous event reporting.","title":"Main Operations"},{"location":"concepts/netconf/#configuration-datastores","text":"Devices maintain separate datastores (e.g., running, candidate, startup), allowing changes to be staged, validated, and committed atomically : a major improvement for safe automation.","title":"Configuration Datastores"},{"location":"concepts/netconf/#advantages","text":"Secure by design (strong transport encryption + authentication). Transaction-like behavior and rollback support. Programmable and automation-friendly, especially when combined with YANG data models. Better suited for large-scale, programmatic network management than SNMP or CLI scraping. NETCONF has become a foundational protocol for modern network automation, SDN, and intent-based networking, widely supported by vendors like Cisco, Juniper, Nokia, Huawei, and others.","title":"Advantages"},{"location":"concepts/netconf_vs_gnmi/","text":"NETCONF vs gNMI","title":"NETCONF vs gNMI"},{"location":"concepts/netconf_vs_gnmi/#netconf-vs-gnmi","text":"","title":"NETCONF vs gNMI"},{"location":"concepts/restconf/","text":"RESTCONF RESTCONF is an IETF-standardized HTTP-based protocol (RFC 8040, January 2017) that provides a programmatic RESTful interface for accessing, configuring, and managing data on network devices (routers, switches, firewalls, etc.). It enables CRUD operations (Create, Read, Update, Delete) on YANG-modeled configuration data, operational state data, RPC operations, and event notifications using standard HTTP methods. It was designed as a RESTful evolution/complement to NETCONF, addressing the need for a more developer-friendly, web-oriented API that leverages familiar HTTP/REST principles while remaining compatible with NETCONF's YANG datastores and models : making it easier to integrate into modern automation tools, web apps, and orchestration systems. Key Characteristics Uses HTTP/HTTPS (typically TLS-secured) for transport \u2192 stateless, request-response model. Encoding \u2192 Primarily JSON (preferred for simplicity and web compatibility); also supports XML; content types like application/yang-data+json or application/yang-data+xml . Paths/URIs \u2192 Resource-oriented, hierarchical paths derived from YANG models (e.g., /restconf/data/openconfig-interfaces:interfaces/interface=eth0 ); supports query parameters for filtering, pagination, content selection (e.g., ?content=config , ?depth= , ?fields= : device-dependent). Relies on YANG data models (RFC 7950) for structure, semantics, and validation; exposes both configuration (\"config true\") and state/operational data. Stateless \u2192 Each HTTP request is independent; no built-in sessions or locks like NETCONF (though some implementations may add extensions). Supports notifications via Server-Sent Events (SSE) or other mechanisms for asynchronous event streams. Security \u2192 Mandatory HTTPS/TLS; supports standard HTTP authentication (Basic, Token, OAuth, etc.). Main Operations (HTTP Methods) GET : Retrieve data (configuration, state, or lists); supports filtering and partial responses. POST : Create new resources (e.g., add interface, user); also used for YANG RPC invocation. PUT : Replace entire resource/subtree (full overwrite). PATCH : Partial update/merge (often with YANG-Patch media type per RFC 8072). DELETE : Remove resources. OPTIONS / HEAD : Discovery and metadata. Additional: Access to /.well-known/restconf or monitoring paths for capabilities discovery; event streams via /restconf/streams . Configuration vs Operational Data Configuration \u2192 Writable data stored in device's conceptual datastore(s); supports access to running config (and sometimes candidate/startup via extensions like RFC 8527 for NMDA). Operational/State \u2192 Read-only runtime data (e.g., interface counters, BGP neighbors). No native candidate datastore or atomic multi-operation transactions like NETCONF : changes are direct and immediate (non-transactional by default); suitable for simpler or incremental updates. Advantages RESTful & familiar \u2192 Uses standard HTTP tools/libraries (curl, Postman, Python requests) \u2192 low barrier for developers and DevOps teams. Web-friendly \u2192 Easy integration with web apps, APIs, CI/CD pipelines, cloud orchestration (Ansible, Terraform, etc.). Lightweight & scalable \u2192 Lower overhead than XML/RPC-based NETCONF for many use cases; stateless design suits distributed systems. Vendor-neutral \u2192 YANG + RESTCONF promotes consistency across multi-vendor environments. Better for rapid prototyping, monitoring, and simple config changes than CLI scraping or full NETCONF stacks. Comparison to NETCONF Transport/Encoding \u2192 RESTCONF: HTTP/HTTPS + JSON/XML; NETCONF: SSH/TLS + XML RPCs. Operations \u2192 RESTCONF: HTTP methods (CRUD); NETCONF: Structured RPCs ( <edit-config> , etc.). Transactions \u2192 NETCONF: Supports candidate datastore, locks, commit/rollback (ACID-like); RESTCONF: Lightweight, no native transactions. Use Cases \u2192 RESTCONF excels at web/automation integration and quick queries; NETCONF better for complex, safe, batched configuration changes. RESTCONF has seen growing adoption (Cisco, Juniper, Huawei, Nokia, Arista, etc.), especially in SDN, intent-based networking, and automation ecosystems : often used alongside NETCONF (for config) and gNMI (for telemetry) to provide a modern, API-driven management plane.","title":"RESTCONF"},{"location":"concepts/restconf/#restconf","text":"RESTCONF is an IETF-standardized HTTP-based protocol (RFC 8040, January 2017) that provides a programmatic RESTful interface for accessing, configuring, and managing data on network devices (routers, switches, firewalls, etc.). It enables CRUD operations (Create, Read, Update, Delete) on YANG-modeled configuration data, operational state data, RPC operations, and event notifications using standard HTTP methods. It was designed as a RESTful evolution/complement to NETCONF, addressing the need for a more developer-friendly, web-oriented API that leverages familiar HTTP/REST principles while remaining compatible with NETCONF's YANG datastores and models : making it easier to integrate into modern automation tools, web apps, and orchestration systems.","title":"RESTCONF"},{"location":"concepts/restconf/#key-characteristics","text":"Uses HTTP/HTTPS (typically TLS-secured) for transport \u2192 stateless, request-response model. Encoding \u2192 Primarily JSON (preferred for simplicity and web compatibility); also supports XML; content types like application/yang-data+json or application/yang-data+xml . Paths/URIs \u2192 Resource-oriented, hierarchical paths derived from YANG models (e.g., /restconf/data/openconfig-interfaces:interfaces/interface=eth0 ); supports query parameters for filtering, pagination, content selection (e.g., ?content=config , ?depth= , ?fields= : device-dependent). Relies on YANG data models (RFC 7950) for structure, semantics, and validation; exposes both configuration (\"config true\") and state/operational data. Stateless \u2192 Each HTTP request is independent; no built-in sessions or locks like NETCONF (though some implementations may add extensions). Supports notifications via Server-Sent Events (SSE) or other mechanisms for asynchronous event streams. Security \u2192 Mandatory HTTPS/TLS; supports standard HTTP authentication (Basic, Token, OAuth, etc.).","title":"Key Characteristics"},{"location":"concepts/restconf/#main-operations-http-methods","text":"GET : Retrieve data (configuration, state, or lists); supports filtering and partial responses. POST : Create new resources (e.g., add interface, user); also used for YANG RPC invocation. PUT : Replace entire resource/subtree (full overwrite). PATCH : Partial update/merge (often with YANG-Patch media type per RFC 8072). DELETE : Remove resources. OPTIONS / HEAD : Discovery and metadata. Additional: Access to /.well-known/restconf or monitoring paths for capabilities discovery; event streams via /restconf/streams .","title":"Main Operations (HTTP Methods)"},{"location":"concepts/restconf/#configuration-vs-operational-data","text":"Configuration \u2192 Writable data stored in device's conceptual datastore(s); supports access to running config (and sometimes candidate/startup via extensions like RFC 8527 for NMDA). Operational/State \u2192 Read-only runtime data (e.g., interface counters, BGP neighbors). No native candidate datastore or atomic multi-operation transactions like NETCONF : changes are direct and immediate (non-transactional by default); suitable for simpler or incremental updates.","title":"Configuration vs Operational Data"},{"location":"concepts/restconf/#advantages","text":"RESTful & familiar \u2192 Uses standard HTTP tools/libraries (curl, Postman, Python requests) \u2192 low barrier for developers and DevOps teams. Web-friendly \u2192 Easy integration with web apps, APIs, CI/CD pipelines, cloud orchestration (Ansible, Terraform, etc.). Lightweight & scalable \u2192 Lower overhead than XML/RPC-based NETCONF for many use cases; stateless design suits distributed systems. Vendor-neutral \u2192 YANG + RESTCONF promotes consistency across multi-vendor environments. Better for rapid prototyping, monitoring, and simple config changes than CLI scraping or full NETCONF stacks.","title":"Advantages"},{"location":"concepts/restconf/#comparison-to-netconf","text":"Transport/Encoding \u2192 RESTCONF: HTTP/HTTPS + JSON/XML; NETCONF: SSH/TLS + XML RPCs. Operations \u2192 RESTCONF: HTTP methods (CRUD); NETCONF: Structured RPCs ( <edit-config> , etc.). Transactions \u2192 NETCONF: Supports candidate datastore, locks, commit/rollback (ACID-like); RESTCONF: Lightweight, no native transactions. Use Cases \u2192 RESTCONF excels at web/automation integration and quick queries; NETCONF better for complex, safe, batched configuration changes. RESTCONF has seen growing adoption (Cisco, Juniper, Huawei, Nokia, Arista, etc.), especially in SDN, intent-based networking, and automation ecosystems : often used alongside NETCONF (for config) and gNMI (for telemetry) to provide a modern, API-driven management plane.","title":"Comparison to NETCONF"},{"location":"concepts/yang/","text":"YANG YANG (Yet Another Next Generation) is a data modeling language used to programmatically represent both configuration and operational state data on network devices. It is defined in RFC 6020 and serves as the foundation for modern, model-driven network management and automation. Purpose and Benefits YANG promotes unification in networking by enabling structured, programmatic interfaces to devices (e.g., routers and switches) using protocols like NETCONF, RESTCONF, or gNMI. It replaces traditional unstructured CLI outputs or legacy protocols like SNMP with vendor-neutral, hierarchical data models that map directly to programmable entities (like JSON structures). Key advantages include: Vendor-neutral modeling for consistency across devices. Structured data for easier automation and integration with tools/languages. Extensibility through augmentations and deviations. Better support for DevOps/NetDevOps workflows (e.g., Ansible, pyATS, Terraform). How YANG Models Work YANG organizes data hierarchically as a tree, where each element is a node with a name and either a value or child nodes. Models are written in modules, which include: Header statements (name, namespace, prefix, imports). Revision statements (version history). Definition statements (the core data model). YANG defines four main node types: Leaf : A single value (no children), e.g., interface name (string) or enabled status (boolean). Leaf-list : An ordered sequence of leaf values. Container : Groups related nodes (no value itself); can be configuration ( config true , read-write) or operational state ( config false , read-only). List : A sequence of entries (like a list of interfaces), each identified by a key (e.g., interface name). Standard vs. Vendor-Specific Models Industry-standard models : Developed by IETF (e.g., ietf-interfaces.yang , ietf-ip.yang ) or OpenConfig for broad compatibility. Vendor-specific (native) models : Tailored to a specfic platform. These are often required when standard models lack coverage for vendor-unique features. All models are publicly available on GitHub: https://github.com/YangModels/yang/ https://github.com/openconfig/public/. Key Features: Augmentations and Deviations Augmentations : Extend base models (e.g., ietf-ip.yang adds IPv4/IPv6 details to ietf-interfaces.yang using augment and conditional when statements). Deviations : Handle implementation differences (e.g., marking a feature as not-supported in a specific OS release). Practical Mapping and Tools YANG structures map naturally to programming concepts, especially Python: YANG Element Python Equivalent Container Dictionary Leaf name Dictionary key Leaf Dictionary value List List String/Boolean/Integer Corresponding types Empty None Tools like Pyang ( pip install pyang ) let you validate models and visualize them as trees (e.g., pyang -f tree ietf-interfaces.yang ).","title":"YANG"},{"location":"concepts/yang/#yang","text":"YANG (Yet Another Next Generation) is a data modeling language used to programmatically represent both configuration and operational state data on network devices. It is defined in RFC 6020 and serves as the foundation for modern, model-driven network management and automation.","title":"YANG"},{"location":"concepts/yang/#purpose-and-benefits","text":"YANG promotes unification in networking by enabling structured, programmatic interfaces to devices (e.g., routers and switches) using protocols like NETCONF, RESTCONF, or gNMI. It replaces traditional unstructured CLI outputs or legacy protocols like SNMP with vendor-neutral, hierarchical data models that map directly to programmable entities (like JSON structures). Key advantages include: Vendor-neutral modeling for consistency across devices. Structured data for easier automation and integration with tools/languages. Extensibility through augmentations and deviations. Better support for DevOps/NetDevOps workflows (e.g., Ansible, pyATS, Terraform).","title":"Purpose and Benefits"},{"location":"concepts/yang/#how-yang-models-work","text":"YANG organizes data hierarchically as a tree, where each element is a node with a name and either a value or child nodes. Models are written in modules, which include: Header statements (name, namespace, prefix, imports). Revision statements (version history). Definition statements (the core data model). YANG defines four main node types: Leaf : A single value (no children), e.g., interface name (string) or enabled status (boolean). Leaf-list : An ordered sequence of leaf values. Container : Groups related nodes (no value itself); can be configuration ( config true , read-write) or operational state ( config false , read-only). List : A sequence of entries (like a list of interfaces), each identified by a key (e.g., interface name).","title":"How YANG Models Work"},{"location":"concepts/yang/#standard-vs-vendor-specific-models","text":"Industry-standard models : Developed by IETF (e.g., ietf-interfaces.yang , ietf-ip.yang ) or OpenConfig for broad compatibility. Vendor-specific (native) models : Tailored to a specfic platform. These are often required when standard models lack coverage for vendor-unique features. All models are publicly available on GitHub: https://github.com/YangModels/yang/ https://github.com/openconfig/public/.","title":"Standard vs. Vendor-Specific Models"},{"location":"concepts/yang/#key-features-augmentations-and-deviations","text":"Augmentations : Extend base models (e.g., ietf-ip.yang adds IPv4/IPv6 details to ietf-interfaces.yang using augment and conditional when statements). Deviations : Handle implementation differences (e.g., marking a feature as not-supported in a specific OS release).","title":"Key Features: Augmentations and Deviations"},{"location":"concepts/yang/#practical-mapping-and-tools","text":"YANG structures map naturally to programming concepts, especially Python: YANG Element Python Equivalent Container Dictionary Leaf name Dictionary key Leaf Dictionary value List List String/Boolean/Integer Corresponding types Empty None Tools like Pyang ( pip install pyang ) let you validate models and visualize them as trees (e.g., pyang -f tree ietf-interfaces.yang ).","title":"Practical Mapping and Tools"},{"location":"reference/network-topology/","text":"Network Topology This tutorial is based on a simple three-node multi-vendor network arranged in a ring topology. The three routers are connected to management network named api-lab using the IPv4 subnet 192.168.100.0/24 . Node Model Management IP ceos-01 Arista cEOS 192.168.100.11 srl-01 Nokia SR Linux node 192.168.100.12 srl-02 Nokia SR Linux node 192.168.100.13","title":"Topology"},{"location":"reference/network-topology/#network-topology","text":"This tutorial is based on a simple three-node multi-vendor network arranged in a ring topology. The three routers are connected to management network named api-lab using the IPv4 subnet 192.168.100.0/24 . Node Model Management IP ceos-01 Arista cEOS 192.168.100.11 srl-01 Nokia SR Linux node 192.168.100.12 srl-02 Nokia SR Linux node 192.168.100.13","title":"Network Topology"},{"location":"reference/troubleshooting/","text":"Troubleshooting","title":"Troubleshooting"},{"location":"reference/troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"setup/docker-images/","text":"Docker images To deploy this lab, you will need these two Docker images: ceos:image : This image is required for the Arista cEOS node ( ceos-01 ). ghcr.io/nokia/srlinux : This image is required for both Nokia SR Linux nodes ( srl-01 and srl-02 ). Getting Arista cEOS image To obtain Arista cEOS images: Register/Login: Create an account on the Arista website . Locate Image: Go to the Software Downloads section, select \"cEOS-lab\", and choose the desired release (this tutorial uses: cEOS-lab-4.35.1F.tar.xz). Download: Download the cEOS-lab-xxx.tar.xz file to your local machine. Transfer: Move the file to your lab environment (e.g., Ubuntu VM or Docker host) using sftp or scp. Import: Import the image into Docker: docker import cEOS-lab-4.35.1F.tar.xz ceos:image Getting SR Linux image Nokia SR Linux follows a free and open distribution model. You can pull SR Linux container from a public registry: docker pull ghcr.io/nokia/srlinux","title":"Docker Images"},{"location":"setup/docker-images/#docker-images","text":"To deploy this lab, you will need these two Docker images: ceos:image : This image is required for the Arista cEOS node ( ceos-01 ). ghcr.io/nokia/srlinux : This image is required for both Nokia SR Linux nodes ( srl-01 and srl-02 ).","title":"Docker images"},{"location":"setup/docker-images/#getting-arista-ceos-image","text":"To obtain Arista cEOS images: Register/Login: Create an account on the Arista website . Locate Image: Go to the Software Downloads section, select \"cEOS-lab\", and choose the desired release (this tutorial uses: cEOS-lab-4.35.1F.tar.xz). Download: Download the cEOS-lab-xxx.tar.xz file to your local machine. Transfer: Move the file to your lab environment (e.g., Ubuntu VM or Docker host) using sftp or scp. Import: Import the image into Docker: docker import cEOS-lab-4.35.1F.tar.xz ceos:image","title":"Getting Arista cEOS image"},{"location":"setup/docker-images/#getting-sr-linux-image","text":"Nokia SR Linux follows a free and open distribution model. You can pull SR Linux container from a public registry: docker pull ghcr.io/nokia/srlinux","title":"Getting SR Linux image"},{"location":"setup/prerequisites/","text":"","title":"Prerequisites"},{"location":"setup/tools/","text":"Tools You will need a the following tools (but not all at once): Infrastructure Linux Environment: A native Linux system or WSL2 on Windows is necessary to run Containerlab and Docker. Docker : Required to run the containerized router images. Containerlab : This is esential to create the lab environment. Protocol Transport Libraries (Python) These libraries allow your automation scripts to communicate with the devices: ncclient: A Python library for NETCONF transport. pygnmi: A Python client library for gNMI. Interactive CLI Tools for Discovery These are used for manual exploration and \"reverse engineering\" before writing code: gnmic: A CLI client for gNMI. It is used to explore device capabilities, retrieve state, and test telemetry subscriptions. netconf-console2: A CLI clients for NETCONF. They are useful for checking connectivity, retrieving schemas, and testing XML filters without writing Python code. YANG Modeling & Validation Tools pyang: The essential tool for YANG visualization. It converts verbose YANG source files into a readable tree format ( pyang -f tree ), which acts as your map for constructing configuration paths. yanglint (libyang2-tools): A command-line utility used for offline validation. It checks your XML or JSON payloads against the YANG schema to catch errors before they ever touch a live device. yangson: A Python library used for programmatic validation and data manipulation within automation scripts. Development & Automation Tools Python 3 & venv: Used for writing the automation logic; virtual environments ( venv ) are recommended to isolate dependencies. Jinja2: A templating engine used to separate the structure of YANG-modeled payloads from the variable data (e.g., IP addresses), making the code more modular. xmltodict: Useful for converting XML-based NETCONF responses into Python dictionaries for easier processing. VSCode with YANG extension: Provides syntax highlighting and tree navigation for YANG files, which is critical when browsing large vendor model repositories.","title":"Tools"},{"location":"setup/tools/#tools","text":"You will need a the following tools (but not all at once):","title":"Tools"},{"location":"setup/tools/#infrastructure","text":"Linux Environment: A native Linux system or WSL2 on Windows is necessary to run Containerlab and Docker. Docker : Required to run the containerized router images. Containerlab : This is esential to create the lab environment.","title":"Infrastructure"},{"location":"setup/tools/#protocol-transport-libraries-python","text":"These libraries allow your automation scripts to communicate with the devices: ncclient: A Python library for NETCONF transport. pygnmi: A Python client library for gNMI.","title":"Protocol Transport Libraries (Python)"},{"location":"setup/tools/#interactive-cli-tools-for-discovery","text":"These are used for manual exploration and \"reverse engineering\" before writing code: gnmic: A CLI client for gNMI. It is used to explore device capabilities, retrieve state, and test telemetry subscriptions. netconf-console2: A CLI clients for NETCONF. They are useful for checking connectivity, retrieving schemas, and testing XML filters without writing Python code.","title":"Interactive CLI Tools for Discovery"},{"location":"setup/tools/#yang-modeling-validation-tools","text":"pyang: The essential tool for YANG visualization. It converts verbose YANG source files into a readable tree format ( pyang -f tree ), which acts as your map for constructing configuration paths. yanglint (libyang2-tools): A command-line utility used for offline validation. It checks your XML or JSON payloads against the YANG schema to catch errors before they ever touch a live device. yangson: A Python library used for programmatic validation and data manipulation within automation scripts.","title":"YANG Modeling &amp; Validation Tools"},{"location":"setup/tools/#development-automation-tools","text":"Python 3 & venv: Used for writing the automation logic; virtual environments ( venv ) are recommended to isolate dependencies. Jinja2: A templating engine used to separate the structure of YANG-modeled payloads from the variable data (e.g., IP addresses), making the code more modular. xmltodict: Useful for converting XML-based NETCONF responses into Python dictionaries for easier processing. VSCode with YANG extension: Provides syntax highlighting and tree navigation for YANG files, which is critical when browsing large vendor model repositories.","title":"Development &amp; Automation Tools"},{"location":"tasks/capabilities/","text":"Task 4 - Inspect Device Capabilities Both NETCONF and gNMI provide a way for a client to discover what a device supports before performing configuration or telemetry operations. NETCONF Capabilities In Task 2 , When you run: netconf-console2 --host=srl-01 --port 830 -u admin -p 'NokiaSrl1!' --hello the device returns the following in XML format: NETCONF versions (1.0, 1.1) and optional features like candidate, confirmed-commit, validate, etc. A detailed list of supported modules, including their URNs, names, revision dates, supported features, deviations, augmentations, and explicitly lists multiple modules per URN. The key characteristics of the output: Includes rich metadata such as feature support, deviations, augmentations, and dependencies. Each YANG module is individually listed, often with query strings for module details. IETF, OpenConfig and vendor-specific modules are included. Supports NMDA (Network Management Datastore Architecture) capabilities. Example: <?xml version='1.0' encoding='UTF-8'?> <nc:hello xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <nc:capabilities> <nc:capability>urn:ietf:params:netconf:base:1.0</nc:capability> <nc:capability>urn:ietf:params:netconf:base:1.1</nc:capability> <nc:capability>urn:ietf:params:netconf:capability:candidate:1.0</nc:capability> <nc:capability>urn:ietf:params:netconf:capability:confirmed-commit:1.1</nc:capability> .... <nc:capability>urn:ietf:params:xml:ns:yang:ietf-yang-library?module=ietf-yang-library&amp;revision=2019-01-04</nc:capability> <nc:capability>urn:nokia.com:srlinux:aaa:aaa?module=srl_nokia-aaa&amp;revision=2025-10-31</nc:capability> <nc:capability>urn:nokia.com:srlinux:aaa:aaa-password?module=srl_nokia-aaa-password&amp;revision=2025-07-31</nc:capability> <nc:capability>urn:nokia.com:srlinux:aaa:aaa-types?module=srl_nokia-aaa-types&amp;revision=2023-03-31</nc:capability> .... gNMI Capabilities In Task 3 , When you run: gnmic -a srl-01:57400 -u admin -p NokiaSrl1! --skip-verify capabilities the device returns the following in plain text: gNMI version (e.g., 0.10.0). List of YANG models by URN, including module name, publisher, and revision date. Supported encodings: Lists encoding formats such as JSON_IETF, PROTO, ASCII, and related numeric codes. The key characteristics of the output: Provides only the essential details for a gNMI client: supported models and encodings. Does not specify per-module features or deviations. Models are listed solely by URNs, without feature flags or module breakdowns. Example: gNMI version: 0.10.0 supported models: - urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring:ietf-netconf-monitoring, IETF NETCONF (Network Configuration) Working Group, 2010-10-04 - urn:ietf:params:xml:ns:yang:ietf-yang-library:ietf-yang-library, IETF NETCONF (Network Configuration) Working Group, 2019-01-04 - urn:nokia.com:srlinux:aaa:aaa:srl_nokia-aaa, Nokia, 2025-10-31 ... - http://openconfig.net/yang/aaa:openconfig-aaa, OpenConfig working group, 2022-07-29 - http://openconfig.net/yang/acl:openconfig-acl, OpenConfig working group, 2023-02-06 - http://openconfig.net/yang/aft/ni:openconfig-aft-network-instance, OpenConfig working group, 2023-04-25 ... In the examples above, the distinction between lines starting with urn: and those starting with http: reflects the naming authority and origin of the YANG models: urn: prefixes indicate Nokia proprietary models (e.g., urn:nokia.com:srlinux:aaa:aaa ). These are internal, vendor-specific schemas defined by Nokia for their SRLinux implementation. They follow a URN format using the nokia.com domain. http:// prefixes indicate IETF or OpenConfig models (e.g., http://openconfig.net/yang/interfaces ). These are industry-standard models defined by OpenConfig working group. https:// prefixes (seen in NETCONF output) indicate OpenConfig gNSI models (e.g., https://github.com/openconfig/yang/gnsi/authz ), though these appear as http:// in the gNMI output for simplicity. This dual-namespace approach allows the device to support both: 1. Standardized models ( http:// ) for multi-vendor compatibility 2. Vendor-specific extensions ( urn: ) for advanced Nokia features not covered by standards Conclusion The gNMI and NETCONF capabilities responses differ in both format and the type of information they convey. NETCONF exposes protocol workflow features while gNMI exposes data model and encoding features. This reflects the different philosophies of the two protocols: NETCONF is designed for transactional, configuration-oriented management with deep model introspection. gNMI is designed for lightweight, high-frequency streaming and minimal overhead. Exercise Compare the capabilities returned by ceo-01 for both NETCONF and gNMI. Does cEOS support the same NETCONF capabilities as SR Linux? Explain the difference in the format of the capabilities returned by gNMI? The differences you notice in both the capabilities, supported models, and formatting, highlight one of the challenges in managing the network via data models in multi-vendor environment.","title":"4. Inspect Capabilities"},{"location":"tasks/capabilities/#task-4-inspect-device-capabilities","text":"Both NETCONF and gNMI provide a way for a client to discover what a device supports before performing configuration or telemetry operations.","title":"Task 4 - Inspect Device Capabilities"},{"location":"tasks/capabilities/#netconf-capabilities","text":"In Task 2 , When you run: netconf-console2 --host=srl-01 --port 830 -u admin -p 'NokiaSrl1!' --hello the device returns the following in XML format: NETCONF versions (1.0, 1.1) and optional features like candidate, confirmed-commit, validate, etc. A detailed list of supported modules, including their URNs, names, revision dates, supported features, deviations, augmentations, and explicitly lists multiple modules per URN. The key characteristics of the output: Includes rich metadata such as feature support, deviations, augmentations, and dependencies. Each YANG module is individually listed, often with query strings for module details. IETF, OpenConfig and vendor-specific modules are included. Supports NMDA (Network Management Datastore Architecture) capabilities. Example: <?xml version='1.0' encoding='UTF-8'?> <nc:hello xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <nc:capabilities> <nc:capability>urn:ietf:params:netconf:base:1.0</nc:capability> <nc:capability>urn:ietf:params:netconf:base:1.1</nc:capability> <nc:capability>urn:ietf:params:netconf:capability:candidate:1.0</nc:capability> <nc:capability>urn:ietf:params:netconf:capability:confirmed-commit:1.1</nc:capability> .... <nc:capability>urn:ietf:params:xml:ns:yang:ietf-yang-library?module=ietf-yang-library&amp;revision=2019-01-04</nc:capability> <nc:capability>urn:nokia.com:srlinux:aaa:aaa?module=srl_nokia-aaa&amp;revision=2025-10-31</nc:capability> <nc:capability>urn:nokia.com:srlinux:aaa:aaa-password?module=srl_nokia-aaa-password&amp;revision=2025-07-31</nc:capability> <nc:capability>urn:nokia.com:srlinux:aaa:aaa-types?module=srl_nokia-aaa-types&amp;revision=2023-03-31</nc:capability> ....","title":"NETCONF Capabilities"},{"location":"tasks/capabilities/#gnmi-capabilities","text":"In Task 3 , When you run: gnmic -a srl-01:57400 -u admin -p NokiaSrl1! --skip-verify capabilities the device returns the following in plain text: gNMI version (e.g., 0.10.0). List of YANG models by URN, including module name, publisher, and revision date. Supported encodings: Lists encoding formats such as JSON_IETF, PROTO, ASCII, and related numeric codes. The key characteristics of the output: Provides only the essential details for a gNMI client: supported models and encodings. Does not specify per-module features or deviations. Models are listed solely by URNs, without feature flags or module breakdowns. Example: gNMI version: 0.10.0 supported models: - urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring:ietf-netconf-monitoring, IETF NETCONF (Network Configuration) Working Group, 2010-10-04 - urn:ietf:params:xml:ns:yang:ietf-yang-library:ietf-yang-library, IETF NETCONF (Network Configuration) Working Group, 2019-01-04 - urn:nokia.com:srlinux:aaa:aaa:srl_nokia-aaa, Nokia, 2025-10-31 ... - http://openconfig.net/yang/aaa:openconfig-aaa, OpenConfig working group, 2022-07-29 - http://openconfig.net/yang/acl:openconfig-acl, OpenConfig working group, 2023-02-06 - http://openconfig.net/yang/aft/ni:openconfig-aft-network-instance, OpenConfig working group, 2023-04-25 ... In the examples above, the distinction between lines starting with urn: and those starting with http: reflects the naming authority and origin of the YANG models: urn: prefixes indicate Nokia proprietary models (e.g., urn:nokia.com:srlinux:aaa:aaa ). These are internal, vendor-specific schemas defined by Nokia for their SRLinux implementation. They follow a URN format using the nokia.com domain. http:// prefixes indicate IETF or OpenConfig models (e.g., http://openconfig.net/yang/interfaces ). These are industry-standard models defined by OpenConfig working group. https:// prefixes (seen in NETCONF output) indicate OpenConfig gNSI models (e.g., https://github.com/openconfig/yang/gnsi/authz ), though these appear as http:// in the gNMI output for simplicity. This dual-namespace approach allows the device to support both: 1. Standardized models ( http:// ) for multi-vendor compatibility 2. Vendor-specific extensions ( urn: ) for advanced Nokia features not covered by standards","title":"gNMI Capabilities"},{"location":"tasks/capabilities/#conclusion","text":"The gNMI and NETCONF capabilities responses differ in both format and the type of information they convey. NETCONF exposes protocol workflow features while gNMI exposes data model and encoding features. This reflects the different philosophies of the two protocols: NETCONF is designed for transactional, configuration-oriented management with deep model introspection. gNMI is designed for lightweight, high-frequency streaming and minimal overhead.","title":"Conclusion"},{"location":"tasks/capabilities/#exercise","text":"Compare the capabilities returned by ceo-01 for both NETCONF and gNMI. Does cEOS support the same NETCONF capabilities as SR Linux? Explain the difference in the format of the capabilities returned by gNMI? The differences you notice in both the capabilities, supported models, and formatting, highlight one of the challenges in managing the network via data models in multi-vendor environment.","title":"Exercise"},{"location":"tasks/start-containerlab/","text":"Task 1 - Starting Containerlab A Containerlab topology is described in a YAML file. If you are not familier with Conatinerlab, here are the basic steps to deploy the topology and interact with the nodes: 1. Start the lab You deploy the lab using the deploy command. sudo containerlab deploy [-t tutroial.clab.yml] The name of the topology file is optinal if there is only one file with this name format in the current folder You will see the summary table with the deployed lab nodes. \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Name \u2502 Kind/Image \u2502 State \u2502 IPv4/6 Address \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 ceos-01 \u2502 arista_ceos \u2502 running \u2502 192.168.100.11 \u2502 \u2502 \u2502 ceos:image \u2502 \u2502 N/A \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 srl-01 \u2502 nokia_srlinux \u2502 running \u2502 192.168.100.12 \u2502 \u2502 \u2502 ghcr.io/nokia/srlinux \u2502 \u2502 N/A \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 srl-02 \u2502 nokia_srlinux \u2502 running \u2502 192.168.100.13 \u2502 \u2502 \u2502 ghcr.io/nokia/srlinux \u2502 \u2502 N/A \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f You can list the nodes of the lab anytime with containerlab inspect command. sudo clab inspect [-t tutroial.clab.yml] clab is an alias of containerlab 2. Access the nodes You can use ssh to access the routers' CLI using the default username/password. Node username password ceos-01 admin admin srl-01, srl-02 admin NokiaSrl1! For example: ssh admin@ceos-01 Since the nodes are Docker containers, you can also connect to them through Docker: # access CLI docker exec -it srl-01 sr_cli # access bash docker exec -it srl-01 bash 3. End the lab You can end the lab using the destroy command: sudo clab destroy [--cleanup] The local --cleanup | -c flag instructs containerlab to remove the lab directory and all its content. Without this flag present, containerlab will keep the lab directory and all files inside of it. Do not use this flag if you want to keep the configuration you saved in the routers. Containerlab CLI has a large set of commands and flags. Check out the Command reference section to get familiar with all the commands and their usage.","title":"1. Start Containerlab"},{"location":"tasks/start-containerlab/#task-1-starting-containerlab","text":"A Containerlab topology is described in a YAML file. If you are not familier with Conatinerlab, here are the basic steps to deploy the topology and interact with the nodes:","title":"Task 1 - Starting Containerlab"},{"location":"tasks/start-containerlab/#1-start-the-lab","text":"You deploy the lab using the deploy command. sudo containerlab deploy [-t tutroial.clab.yml] The name of the topology file is optinal if there is only one file with this name format in the current folder You will see the summary table with the deployed lab nodes. \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Name \u2502 Kind/Image \u2502 State \u2502 IPv4/6 Address \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 ceos-01 \u2502 arista_ceos \u2502 running \u2502 192.168.100.11 \u2502 \u2502 \u2502 ceos:image \u2502 \u2502 N/A \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 srl-01 \u2502 nokia_srlinux \u2502 running \u2502 192.168.100.12 \u2502 \u2502 \u2502 ghcr.io/nokia/srlinux \u2502 \u2502 N/A \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 srl-02 \u2502 nokia_srlinux \u2502 running \u2502 192.168.100.13 \u2502 \u2502 \u2502 ghcr.io/nokia/srlinux \u2502 \u2502 N/A \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f You can list the nodes of the lab anytime with containerlab inspect command. sudo clab inspect [-t tutroial.clab.yml] clab is an alias of containerlab","title":"1. Start the lab"},{"location":"tasks/start-containerlab/#2-access-the-nodes","text":"You can use ssh to access the routers' CLI using the default username/password. Node username password ceos-01 admin admin srl-01, srl-02 admin NokiaSrl1! For example: ssh admin@ceos-01 Since the nodes are Docker containers, you can also connect to them through Docker: # access CLI docker exec -it srl-01 sr_cli # access bash docker exec -it srl-01 bash","title":"2. Access the nodes"},{"location":"tasks/start-containerlab/#3-end-the-lab","text":"You can end the lab using the destroy command: sudo clab destroy [--cleanup] The local --cleanup | -c flag instructs containerlab to remove the lab directory and all its content. Without this flag present, containerlab will keep the lab directory and all files inside of it. Do not use this flag if you want to keep the configuration you saved in the routers. Containerlab CLI has a large set of commands and flags. Check out the Command reference section to get familiar with all the commands and their usage.","title":"3. End the lab"},{"location":"tasks/verify-gnmi/","text":"Task 3 - Verify gNMI Connectivity Verify that gNMI is reachable (typically on port 57400) using the gnmic client: gnmic -a ceos-01:6030 -u admin -p admin --insecure capabilities You will need a different port number and flag for SR Linux routers gnmic -a srl-01:57400 -u admin -p NokiaSrl1! --skip-verify capabilities Install gnmic using: bash -c \"$(curl -sL https://get-gnmic.openconfig.net)\"","title":"3. Verify gNMI"},{"location":"tasks/verify-gnmi/#task-3-verify-gnmi-connectivity","text":"Verify that gNMI is reachable (typically on port 57400) using the gnmic client: gnmic -a ceos-01:6030 -u admin -p admin --insecure capabilities You will need a different port number and flag for SR Linux routers gnmic -a srl-01:57400 -u admin -p NokiaSrl1! --skip-verify capabilities Install gnmic using: bash -c \"$(curl -sL https://get-gnmic.openconfig.net)\"","title":"Task 3 - Verify gNMI Connectivity"},{"location":"tasks/verify-netconf/","text":"Task 2 - Verify NETCONF Connectivity The goal of this task is to initiate a connection to each device and retrieve the HELLO message exchanged at the start of a NETCONF session. This message advertises the device capabilities (such as supported YANG models and protocol features). The NETCONF protocol is designed to run securely over SSH, and port 830 is assigned as the standard default port for this connection. Once the lab is running, verify that NETCONF is reachable on port 830 using netconf-console2: netconf-console2 --host=srl-01 --port 830 -u admin -p NokiaSrl1! --hello Install netconf-console2 using pip install netconf-console2 Alternatively, you may use raw ssh connection: ssh admin@ceos-01 -p 830 -s netconf What Both Commands Are Actually Doing netconf-console2 is a dedicated NETCONF client. It handles the SSH transport internally, sends a proper NETCONF message with its own capabilities, waits for the device's in response, and then presents the result to you cleanly. It understands the NETCONF framing protocol (the ]]>]]> end-of-message marker in NETCONF 1.0, or chunked framing in 1.1). ssh -s netconf is raw SSH. It opens the subsystem channel but does nothing after that. You are dropped directly into the NETCONF session at the XML layer. The device sends its message immediately, and then waits for yours. If you just sit there, nothing further happens \u2014 you would need to type raw XML to continue. It is useful for confirming the port is open and the device is responding, but it is not a practical way to send operations.","title":"2. Verify NETCONF"},{"location":"tasks/verify-netconf/#task-2-verify-netconf-connectivity","text":"The goal of this task is to initiate a connection to each device and retrieve the HELLO message exchanged at the start of a NETCONF session. This message advertises the device capabilities (such as supported YANG models and protocol features). The NETCONF protocol is designed to run securely over SSH, and port 830 is assigned as the standard default port for this connection. Once the lab is running, verify that NETCONF is reachable on port 830 using netconf-console2: netconf-console2 --host=srl-01 --port 830 -u admin -p NokiaSrl1! --hello Install netconf-console2 using pip install netconf-console2 Alternatively, you may use raw ssh connection: ssh admin@ceos-01 -p 830 -s netconf What Both Commands Are Actually Doing netconf-console2 is a dedicated NETCONF client. It handles the SSH transport internally, sends a proper NETCONF message with its own capabilities, waits for the device's in response, and then presents the result to you cleanly. It understands the NETCONF framing protocol (the ]]>]]> end-of-message marker in NETCONF 1.0, or chunked framing in 1.1). ssh -s netconf is raw SSH. It opens the subsystem channel but does nothing after that. You are dropped directly into the NETCONF session at the XML layer. The device sends its message immediately, and then waits for yours. If you just sit there, nothing further happens \u2014 you would need to type raw XML to continue. It is useful for confirming the port is open and the device is responding, but it is not a practical way to send operations.","title":"Task 2 - Verify NETCONF Connectivity"}]}